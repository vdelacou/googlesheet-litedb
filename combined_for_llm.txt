// Filename: .vscode/extensions.json
{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "eamodio.gitlens",
    "usernamehw.errorlens",
    "lacroixdavid1.vscode-format-context-menu",
    "kisstkondoros.vscode-codemetrics",
    "snyk-security.snyk-vulnerability-scanner",
    "sonarsource.sonarlint-vscode",
  ]
}

// Filename: .vscode/settings.json
{
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.organizeImports": "explicit",
        "source.addMissingImports": "explicit",
        "source.fixAll.eslint": "explicit"
    },
    "search.exclude": {
        "**/node_modules": true,
        "**/.vscode": true
    },
    "search.useGlobalIgnoreFiles": true,
    "search.useParentIgnoreFiles": true,
    "git.autofetch": true,
    "editor.trimAutoWhitespace": true,
    "files.encoding": "utf8",
    "files.trimFinalNewlines": true,
    "files.trimTrailingWhitespace": true,
    "editor.quickSuggestions": {
        "strings": true
    },
    "editor.detectIndentation": false,
    "editor.tabSize": 2,
    "eslint.enable": true,
    "eslint.format.enable": true,
    "editor.defaultFormatter": "dbaeumer.vscode-eslint",
    "editor.formatOnType": true,
    "typescript.format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces": false,
    "[typescript]": {
        "editor.defaultFormatter": "vscode.typescript-language-features"
    },
    "[javascript]": {
        "editor.defaultFormatter": "vscode.typescript-language-features"
    },
    "[jsonc]": {
        "editor.defaultFormatter": "vscode.json-language-features"
    }
}

// Filename: Dockerfile
FROM oven/bun:1 AS base
WORKDIR /usr/src/app

# install dependencies into temp directory
FROM base AS install
RUN mkdir -p /temp/dev /temp/prod
COPY package.json bun.lockb /temp/dev/
WORKDIR /temp/dev
RUN bun install --frozen-lockfile
COPY package.json bun.lockb /temp/prod/
WORKDIR /temp/prod
RUN bun install --frozen-lockfile --production

# copy node_modules from temp directory
# then copy all (non-ignored) project files into the image
FROM base AS prerelease
COPY --from=install /temp/dev/node_modules node_modules
COPY . .

# [optional] eslint (can also add test)
ENV NODE_ENV=production
RUN bun run lint

# copy production dependencies and source code into final image
FROM base AS release
COPY --from=install /temp/prod/node_modules node_modules
COPY --from=prerelease /usr/src/app/src/ src/
COPY --from=prerelease /usr/src/app/package.json .

# run the app
USER bun
EXPOSE 8080/tcp
ENTRYPOINT [ "bun", "run", "src/index.ts" ]

// Filename: README.md
# googlesheet-litedb

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run src/index.ts
```

This project was created using `bun init` in bun v1.1.38. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.


// Filename: all_files_combined.txt
// Filename: .vscode/extensions.json
{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "eamodio.gitlens",
    "usernamehw.errorlens",
    "lacroixdavid1.vscode-format-context-menu",
    "kisstkondoros.vscode-codemetrics",
    "snyk-security.snyk-vulnerability-scanner",
    "sonarsource.sonarlint-vscode",
  ]
}

// Filename: .vscode/settings.json
{
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.organizeImports": "explicit",
        "source.addMissingImports": "explicit",
        "source.fixAll.eslint": "explicit"
    },
    "search.exclude": {
        "**/node_modules": true,
        "**/.vscode": true
    },
    "search.useGlobalIgnoreFiles": true,
    "search.useParentIgnoreFiles": true,
    "git.autofetch": true,
    "editor.trimAutoWhitespace": true,
    "files.encoding": "utf8",
    "files.trimFinalNewlines": true,
    "files.trimTrailingWhitespace": true,
    "editor.quickSuggestions": {
        "strings": true
    },
    "editor.detectIndentation": false,
    "editor.tabSize": 2,
    "eslint.enable": true,
    "eslint.format.enable": true,
    "editor.defaultFormatter": "dbaeumer.vscode-eslint",
    "editor.formatOnType": true,
    "typescript.format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces": false,
    "[typescript]": {
        "editor.defaultFormatter": "vscode.typescript-language-features"
    },
    "[javascript]": {
        "editor.defaultFormatter": "vscode.typescript-language-features"
    },
    "[jsonc]": {
        "editor.defaultFormatter": "vscode.json-language-features"
    }
}

// Filename: Dockerfile
FROM oven/bun:1 AS base
WORKDIR /usr/src/app

# install dependencies into temp directory
FROM base AS install
RUN mkdir -p /temp/dev /temp/prod
COPY package.json bun.lockb /temp/dev/
WORKDIR /temp/dev
RUN bun install --frozen-lockfile
COPY package.json bun.lockb /temp/prod/
WORKDIR /temp/prod
RUN bun install --frozen-lockfile --production

# copy node_modules from temp directory
# then copy all (non-ignored) project files into the image
FROM base AS prerelease
COPY --from=install /temp/dev/node_modules node_modules
COPY . .

# [optional] eslint (can also add test)
ENV NODE_ENV=production
RUN bun run lint

# copy production dependencies and source code into final image
FROM base AS release
COPY --from=install /temp/prod/node_modules node_modules
COPY --from=prerelease /usr/src/app/src/ src/
COPY --from=prerelease /usr/src/app/package.json .

# run the app
USER bun
EXPOSE 8080/tcp
ENTRYPOINT [ "bun", "run", "src/index.ts" ]

// Filename: README.md
# googlesheet-litedb

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run src/index.ts
```

This project was created using `bun init` in bun v1.1.38. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.


// Filename: eslint.config.js
import pluginJs from '@eslint/js';
import prettier from 'eslint-plugin-prettier';
import securityPlugin from 'eslint-plugin-security';
import unicornPlugin from 'eslint-plugin-unicorn';
import globals from 'globals';
import tsPlugin from 'typescript-eslint';

/** @type {import('eslint').Linter.Config[]} */
export default [
  // Security
  securityPlugin.configs.recommended,
  {
    files: ['**/*.ts'],
  },
  {
    languageOptions: { globals: globals.node },
  },
  {
    rules: {
      'func-style': ['error', 'expression'],
      'no-restricted-syntax': ['off', 'ForOfStatement'],
      'no-console': ['error'],
      'prefer-template': 'error',
      quotes: ['error', 'single', { avoidEscape: true }],
    },
  },
  // TypeScript Eslint
  {
    rules: {
      '@typescript-eslint/explicit-function-return-type': 'error',
      '@typescript-eslint/consistent-type-definitions': ['error', 'type'],
    },
  },
  // Prettier
  {
    plugins: {
      prettier,
    },
    rules: {
      'prettier/prettier': [
        1,
        {
          endOfLine: 'lf',
          printWidth: 180,
          semi: true,
          singleQuote: true,
          tabWidth: 2,
          trailingComma: 'es5',
        },
      ],
    },
  },
  // Unicorn
  {
    plugins: {
      unicorn: unicornPlugin,
    },
    rules: {
      'unicorn/empty-brace-spaces': 'off',
      'unicorn/no-null': 'off',
    },
  },
  pluginJs.configs.recommended,
  ...tsPlugin.configs.recommended,
];


// Filename: package.json
{
  "name": "googlesheet-litedb",
  "module": "src/index.ts",
  "type": "module",
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/bun": "latest",
    "eslint": "^9.17.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-security": "^3.0.1",
    "eslint-plugin-unicorn": "^56.0.1",
    "typescript-eslint": "^8.19.1"
  },
  "peerDependencies": {
    "typescript": "^5.0.0"
  },
  "dependencies": {
    "google-auth-library": "^9.15.0",
    "google-spreadsheet": "^4.1.4",
    "googleapis": "^144.0.0",
    "winston": "^3.17.0"
  },
  "scripts": {
    "lint": "eslint"
  }
}

// Filename: src/app/index.ts
import { createLogger, format, transports } from 'winston';
import { defaultScopes, type SheetsConfig } from '../infra/config/google';
import { createSheetsRepository } from '../infra/repository/google';

const logger = createLogger({
  level: 'info',
  format: format.simple(),
  transports: [new transports.Console()],
});

const config: SheetsConfig = {
  spreadsheetId: '1Bgv4A0RAkAyPeveFAXHz3WBZ3dEPUtitKSU48bue_0k',
  sheetName: 'Users',
  scopes: defaultScopes,
};

const example = async (): Promise<void> => {
  // Initialize repository and service
  const userRepository = createSheetsRepository(config);

  // Create user
  const newUser = await userRepository.insert({
    id: crypto.randomUUID(),
    name: 'John Doe',
    email: 'john@example.com',
    numberOfChildren: 2,
    createdAt: new Date(),
  });
  logger.info('New user created', newUser);

  // const users = await userRepository.findAll();
  // logger.info('Users found', { length: users.length });

  // Find user
  const user = await userRepository.findBy({ id: '1' });
  logger.info('User found', user);

  // // Search users
  // const usersFoundBy = await userRepository.findBy({ name: 'John Doe' });
  // logger.info('Users found', usersFoundBy);

  // // Update user
  // const updatedUser = await userRepository.update('1', { name: 'Jane Doe' });
  // logger.info('User updated', updatedUser);

  // // Delete user
  // const deleted = await userRepository.delete('1');
  // logger.info('User deleted', deleted);
};

example();


// Filename: src/common/types/observability/index.ts
export * from './logger';


// Filename: src/common/types/observability/logger/index.ts
export type Logger = {
  info(message: string, object?: object): void;
  error(message: string, object?: object): void;
};


// Filename: src/common/types/result/index.ts
type Fail<ERROR> = {
  data?: never;
  error: ERROR;
};

type Success<RESPONSE> = {
  error?: never;
  data: RESPONSE;
};

export type Result<RESPONSE, ERROR> = NonNullable<Success<RESPONSE> | Fail<ERROR>>;

export const createFail = <ERROR>(error: ERROR): Fail<ERROR> => ({ error });

export const createSuccess = <RESPONSE>(data: RESPONSE): Success<RESPONSE> => ({ data });

export const createSuccessVoid = (): Success<void> => ({ data: undefined });


// Filename: src/common/utils/error/index.ts
type ErrorWithMessage = {
  message: string;
};

const isErrorWithMessage = (error: unknown): error is ErrorWithMessage =>
  typeof error === 'object' && error !== null && 'message' in error && typeof (error as Record<string, unknown>).message === 'string';

const toErrorWithMessage = (maybeError: unknown): ErrorWithMessage => {
  if (isErrorWithMessage(maybeError)) {
    return maybeError;
  }

  try {
    return new Error(JSON.stringify(maybeError));
  } catch {
    // fallback in case there's an error stringifying the maybeError
    // like with circular references for example.
    return new Error(String(maybeError));
  }
};

export const getErrorMessage = (error: unknown): string => toErrorWithMessage(error).message;


// Filename: src/domain/repository/index.ts
export type Repository<T> = {
  findAll(): Promise<T[]>;
  findBy(criteria: Partial<T>): Promise<T[]>;
  insert(entity: T): Promise<T>;
  updateBy(idCriteria: Partial<T>, entity: Partial<T>): Promise<T>;
  deleteBy(idCriteria: Partial<T>): Promise<boolean>;
};


// Filename: src/infra/config/google/index.ts
export type SheetsConfig = {
  spreadsheetId: string;
  sheetName: string;
  scopes: string[];
};
export const defaultScopes = ['https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive.file'];


// Filename: src/infra/helpers/google/create-auth-client/index.ts
import { AuthClient, GoogleAuth } from 'google-auth-library';
import { defaultScopes } from '../../../config/google';

export const createAuthClient = async (scopes = defaultScopes): Promise<AuthClient> => {
  // This will use gcloud CLI credentials
  const auth = new GoogleAuth({ scopes });

  const client = await auth.getClient();
  return client;
};


// Filename: src/infra/helpers/google/initialize-google-sheets/index.ts
import { OAuth2Client } from 'google-auth-library';
import { google, sheets_v4 } from 'googleapis';
import type { SheetsConfig } from '../../../config/google';
import { createAuthClient } from '../create-auth-client';

export type SheetsInstance = {
  auth: OAuth2Client;
  sheets: sheets_v4.Sheets;
  spreadsheetId: string;
  sheetName: string;
};

export const initializeSheets = async (config: SheetsConfig): Promise<SheetsInstance> => {
  const authClient = (await createAuthClient(config.scopes)) as OAuth2Client;
  const sheets = google.sheets({ version: 'v4', auth: authClient });
  return {
    auth: authClient,
    sheets,
    spreadsheetId: config.spreadsheetId,
    sheetName: config.sheetName,
  };
};


// Filename: src/infra/repository/google/index.ts
import type { Repository } from '../../../domain/repository';
import type { SheetsConfig } from '../../config/google';
import { initializeSheets, type SheetsInstance } from '../../helpers/google/initialize-google-sheets';

type Headers = { headers: string[] };

const ASCII_A = 65;

type RuntimeType = 'date' | 'array' | 'null' | 'object' | 'undefined' | 'boolean' | 'number' | 'string' | 'bigint' | 'symbol' | 'function';
const getKeyTypePairs = <T>(obj: T): Map<string, RuntimeType> => {
  const map = new Map<string, RuntimeType>();
  Object.entries(obj as Record<string, unknown>).forEach(([key, val]) => {
    let runtimeType = typeof val as RuntimeType;
    if (val instanceof Date) {
      runtimeType = 'date';
    }
    if (Array.isArray(val)) {
      runtimeType = 'array';
    }
    if (val === null) {
      runtimeType = 'null';
    }
    map.set(key, runtimeType);
  });
  return map;
};

/**
 * Convert each property of `obj` to a string using the types from `getKeyTypePairs`.
 */
const convertObjectValuesToString = <T>(obj: T, typeMap: Map<string, RuntimeType>): Record<keyof T, string> => {
  const result = {} as Record<keyof T, string>;

  for (const key of Object.keys(obj) as Array<keyof T>) {
    const value = obj[key];
    const runtimeType = typeMap.get(key as string) ?? 'string'; // fallback

    // Default string conversion
    let converted = String(value);

    switch (runtimeType) {
      case 'date':
        converted = (value as Date).toISOString();
        break;
      case 'array':
      case 'object':
        converted = JSON.stringify(value);
        break;
      case 'null':
        converted = 'null';
        break;
      case 'undefined':
        converted = 'undefined';
        break;
      default:
        // 'boolean', 'number', 'string', 'bigint', 'symbol', 'function' → just String(value)
        break;
    }

    result[key] = converted;
  }

  return result;
};

const restoreObjectFromString = <T>(stringObj: Record<keyof T, string>, typeMap: Map<string, RuntimeType>): T => {
  const newObj = {} as T;

  for (const key of Object.keys(stringObj) as (keyof T)[]) {
    const strValue = stringObj[key];
    const rtType = typeMap.get(key as string) ?? 'string';

    let actualValue: unknown;

    switch (rtType) {
      case 'date':
        // Convert the ISO string back to a Date
        actualValue = new Date(strValue);
        break;
      case 'array':
      case 'object':
        // JSON strings → parse back to array or object
        try {
          actualValue = JSON.parse(strValue);
        } catch {
          actualValue = strValue; // Fallback if JSON.parse fails
        }
        break;
      case 'null':
        actualValue = null;
        break;
      case 'undefined':
        actualValue = undefined;
        break;
      case 'boolean':
        // If the original was a boolean, assume strValue is "true" or "false"
        actualValue = strValue === 'true';
        break;
      case 'number':
        // Convert back to a number. (Could be float or integer.)
        actualValue = Number(strValue);
        break;
      case 'bigint':
        // Convert back to BigInt
        actualValue = BigInt(strValue);
        break;
      case 'symbol':
      case 'function':
        // There's no standard way to restore these from a string.
        actualValue = undefined;
        break;
      case 'string':
      default:
        // Just use the raw string
        actualValue = strValue;
        break;
    }

    newObj[key] = actualValue as T[keyof T];
  }

  return newObj;
};

/**
 * Convert any JavaScript value to a string suitable for Google Sheets.
 */
const stringifyValue = (value: unknown): string => {
  if (value === null || value === undefined) return '';
  if (typeof value === 'object' || Array.isArray(value)) return JSON.stringify(value);
  return String(value);
};

/**
 * Try to parse a string back into a JSON object/array. On parse failure, return the string.
 */
const parseValue = (value: string): unknown => {
  try {
    return JSON.parse(value);
  } catch {
    return value;
  }
};

/**
 * Given a list of headers, return the indexes of required fields.
 */
const getRequiredColumnIndexes = (headers: string[], requiredFields: string[]): number[] => {
  return requiredFields.map((field) => headers.indexOf(field)).filter((index) => index !== -1);
};

/**
 * Convert rows (2D arrays) into entities by matching columns to headers.
 */
const mapRowsToEntities = <T>(headers: string[], rows: string[][], requiredFields?: string[]): T[] => {
  // If fields are specified, only use those; otherwise, use all headers.
  const columnIndexes = requiredFields ? getRequiredColumnIndexes(headers, requiredFields) : [...Array(headers.length).keys()];

  return rows.map((row) => {
    const entity: Record<string, unknown> = {};

    columnIndexes.forEach((index) => {
      // Safely get the header name
      const header = headers.at(index) ?? '';
      // Use .at() to get the cell value
      const cellValue = row.at(index) ?? '';
      entity[`${header}`] = parseValue(cellValue);
    });

    return entity as T;
  });
};

/**
 * Build a Google Sheets A1-notation range (e.g., "Sheet1!A2:C5").
 */
const buildRange = (sheetName: string, startColIndex: number, endColIndex: number, startRow = 1, endRow?: number): string => {
  const startColLetter = String.fromCharCode(ASCII_A + startColIndex);
  const endColLetter = String.fromCharCode(ASCII_A + endColIndex);
  const start = `${startColLetter}${startRow}`;
  const end = endRow ? `${endColLetter}${endRow}` : endColLetter;

  return `${sheetName}!${start}:${end}`;
};

/**
 * Find the row (0-based) in a given column that matches a specified value.
 * Returns -1 if not found.
 */
const findRowIndexByColumnValue = (columnValues: string[][] | undefined, searchValue: string): number => {
  if (!columnValues) return -1;

  // Each row in columnValues is a single-element array: [value].
  return columnValues.findIndex((row) => row.at(0) === searchValue);
};

export const createSheetsRepository = <T>(config: SheetsConfig): Repository<T> => {
  let sheetsInstance: SheetsInstance | null = null;
  let cachedHeaders: string[] | null = null;

  /**
   * Lazily initialize the Google Sheets instance.
   */
  const getSheetsInstance = async (): Promise<SheetsInstance> => {
    if (!sheetsInstance) {
      sheetsInstance = await initializeSheets(config);
    }
    return sheetsInstance;
  };

  /**
   * Retrieve the cached headers if available; otherwise fetch them from the sheet.
   */
  const getHeaders = async (): Promise<Headers> => {
    if (cachedHeaders) return { headers: cachedHeaders };

    const { sheets, spreadsheetId } = await getSheetsInstance();
    const headerResponse = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `${config.sheetName}!1:1`,
    });

    cachedHeaders = headerResponse.data.values?.at(0) ?? [];
    return { headers: cachedHeaders };
  };

  /**
   * Retrieve all rows from the sheet matching the specified fields.
   */
  const findAllBy = async (fields?: (keyof T)[]): Promise<T[]> => {
    const { headers } = await getHeaders();
    const requiredFields = fields?.map(String) ?? headers;

    // Find which columns to fetch
    const columnIndexes = getRequiredColumnIndexes(headers, requiredFields);
    if (columnIndexes.length === 0) return [];

    const startColIndex = Math.min(...columnIndexes);
    const endColIndex = Math.max(...columnIndexes);

    const { sheets, spreadsheetId } = await getSheetsInstance();
    const range = buildRange(config.sheetName, startColIndex, endColIndex, 2);

    const rowsResponse = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range,
    });

    const rows = rowsResponse.data.values ?? [];
    return mapRowsToEntities<T>(headers, rows, requiredFields);
  };

  const findAll = async (fields?: (keyof T)[]): Promise<T[]> => {
    const { headers } = await getHeaders();
    const requiredFields = fields?.map(String) ?? headers;

    // Find which columns to fetch
    const columnIndexes = getRequiredColumnIndexes(headers, requiredFields);
    if (columnIndexes.length === 0) return [];

    const startColIndex = Math.min(...columnIndexes);
    const endColIndex = Math.max(...columnIndexes);

    const { sheets, spreadsheetId } = await getSheetsInstance();
    const range = buildRange(config.sheetName, startColIndex, endColIndex, 2);

    const rowsResponse = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range,
    });

    const rows = rowsResponse.data.values ?? [];
    return mapRowsToEntities<T>(headers, rows, requiredFields);
  };

  /**
   * Retrieve rows from the sheet that match the given criteria.
   */
  const findBy = async (criteria: Partial<T>): Promise<T[]> => {
    // Include all criteria keys
    const allFields = Object.keys(criteria);
    console.info('allFields', allFields);

    // find all headers
    const { headers } = await getHeaders();
    console.info('headers', headers);

    // find all the values for the columns that match the criteria
    const values = await findAll(allFields as (keyof T)[]);
    console.info('values', values);

    // find the rows number that match the criteria
    const rowIndexes = values.map((row, index) => {
      const matchesCriteria = Object.entries(criteria).every(([key, value]) => {
        const valueToFind = (row as Record<string, unknown>)[key];
        console.log('valueToFind', valueToFind);
        console.log('value', value);
        return valueToFind === value;
      });
      if (matchesCriteria) {
        return [index];
      }
      return [];
    });

    console.info('rowIndexes', rowIndexes);

    return [];
  };

  /**
   * Insert a new entity as a row into the sheet.
   */
  const insert = async (entity: T): Promise<T> => {
    const keyTypePairs = getKeyTypePairs(entity);
    console.info('keyTypePairs', keyTypePairs);
    const stringifiedEntity = convertObjectValuesToString(entity, keyTypePairs);
    console.info('stringifiedEntity', stringifiedEntity);
    const restoredEntity = restoreObjectFromString(stringifiedEntity, keyTypePairs);
    console.info('restoredEntity', restoredEntity);

    const { headers } = await getHeaders();
    const { sheets, spreadsheetId } = await getSheetsInstance();

    // Build a row of strings in the same order as the headers
    const row = headers.map((header) => {
      const value = (entity as Record<string, unknown>)[`${header}`];
      return stringifyValue(value);
    });

    await sheets.spreadsheets.values.append({
      spreadsheetId,
      range: buildRange(config.sheetName, 0, headers.length - 1),
      valueInputOption: 'RAW',
      requestBody: { values: [row] },
    });

    return entity;
  };

  /**
   * Update an existing entity identified by idCriteria with new data from entity.
   */
  const updateBy = async (idCriteria: Partial<T>, entity: Partial<T>): Promise<T> => {
    const { headers } = await getHeaders();
    const { sheets, spreadsheetId } = await getSheetsInstance();

    // We'll assume there's only one field in idCriteria that uniquely identifies the row
    const idField = Object.keys(idCriteria).at(0);
    if (!idField) {
      throw new Error('No ID field specified in idCriteria for update.');
    }

    const idColumnIndex = headers.indexOf(idField);
    if (idColumnIndex === -1) {
      throw new Error('ID field "${idField}" not found in headers.');
    }

    const idValue = stringifyValue(idCriteria[`${idField}` as keyof typeof idCriteria]);
    const idRange = buildRange(config.sheetName, idColumnIndex, idColumnIndex);

    // Fetch the column with IDs to locate the row
    const idColumnResponse = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: idRange,
    });

    const rowIndex = findRowIndexByColumnValue(idColumnResponse.data.values ?? [], idValue);
    if (rowIndex === -1) {
      throw new Error(`Entity with ${idField}=${idValue} not found.`);
    }

    // Convert the update fields to a list of column indexes
    const updateFields = Object.keys(entity);
    const updateColumnIndexes = getRequiredColumnIndexes(headers, updateFields);

    // For each column to update, create an update call
    for (let i = 0; i < updateColumnIndexes.length; i += 1) {
      const colIndex = updateColumnIndexes.at(i);
      if (colIndex === undefined) continue;

      const fieldName = updateFields.at(i);
      if (!fieldName) continue;
      const cellRange = buildRange(config.sheetName, colIndex, colIndex, rowIndex + 2, rowIndex + 2);
      const newValue = stringifyValue(entity[fieldName as keyof typeof entity]);

      await sheets.spreadsheets.values.update({
        spreadsheetId,
        range: cellRange,
        valueInputOption: 'RAW',
        requestBody: { values: [[newValue]] },
      });
    }

    // Return the updated entity
    return findBy(idCriteria) as Promise<T>;
  };

  /**
   * Delete a row identified by idCriteria.
   */
  const deleteBy = async (idCriteria: Partial<T>): Promise<boolean> => {
    const { headers } = await getHeaders();
    const { sheets, spreadsheetId } = await getSheetsInstance();

    const idField = Object.keys(idCriteria).at(0);
    if (!idField) return false;

    const idColumnIndex = headers.indexOf(idField);
    if (idColumnIndex === -1) return false;

    const idValue = stringifyValue(idCriteria[idField as keyof typeof idCriteria]);
    const idRange = buildRange(config.sheetName, idColumnIndex, idColumnIndex);
    const idColumnResponse = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: idRange,
    });

    const rowIndex = findRowIndexByColumnValue(idColumnResponse.data.values ?? [], idValue);
    if (rowIndex === -1) return false;

    // Clear the entire row
    const clearRange = buildRange(config.sheetName, 0, headers.length - 1, rowIndex + 2, rowIndex + 2);

    await sheets.spreadsheets.values.clear({
      spreadsheetId,
      range: clearRange,
    });

    return true;
  };

  return {
    findAll,
    findBy,
    insert,
    updateBy,
    deleteBy,
  };
};


// Filename: tsconfig.json
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}




// Filename: eslint.config.js
import pluginJs from '@eslint/js';
import prettier from 'eslint-plugin-prettier';
import securityPlugin from 'eslint-plugin-security';
import unicornPlugin from 'eslint-plugin-unicorn';
import globals from 'globals';
import tsPlugin from 'typescript-eslint';

/** @type {import('eslint').Linter.Config[]} */
export default [
  // Security
  securityPlugin.configs.recommended,
  {
    files: ['**/*.ts'],
  },
  {
    languageOptions: { globals: globals.node },
  },
  {
    rules: {
      'func-style': ['error', 'expression'],
      'no-restricted-syntax': ['off', 'ForOfStatement'],
      'no-console': ['error'],
      'prefer-template': 'error',
      quotes: ['error', 'single', { avoidEscape: true }],
    },
  },
  // TypeScript Eslint
  {
    rules: {
      '@typescript-eslint/explicit-function-return-type': 'error',
      '@typescript-eslint/consistent-type-definitions': ['error', 'type'],
    },
  },
  // Prettier
  {
    plugins: {
      prettier,
    },
    rules: {
      'prettier/prettier': [
        1,
        {
          endOfLine: 'lf',
          printWidth: 180,
          semi: true,
          singleQuote: true,
          tabWidth: 2,
          trailingComma: 'es5',
        },
      ],
    },
  },
  // Unicorn
  {
    plugins: {
      unicorn: unicornPlugin,
    },
    rules: {
      'unicorn/empty-brace-spaces': 'off',
      'unicorn/no-null': 'off',
    },
  },
  pluginJs.configs.recommended,
  ...tsPlugin.configs.recommended,
];


// Filename: example/index.ts
import { BaseExternalAccountClient, GoogleAuth } from 'google-auth-library';
import { google } from 'googleapis';
import { createLogger, format, transports } from 'winston';
import { createSheetsRepository } from '../src/repository';
import type { TableConfig } from '../src/types/config';

const logger = createLogger({
  level: 'info',
  format: format.json(),
  transports: [new transports.Console()],
});

export type User = {
  id: string;
  name: string;
  email: string;
  numberOfChildren: number;
  createdAt: Date;
};

const example = async (): Promise<void> => {
  const defaultScopes = ['https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive.file'];
  const auth = new GoogleAuth({ scopes: defaultScopes });
  const authClient = (await auth.getClient()) as BaseExternalAccountClient;
  const sheets = google.sheets({ version: 'v4', auth: authClient });

  const userTableConfig: TableConfig = {
    spreadsheetId: '1Bgv4A0RAkAyPeveFAXHz3WBZ3dEPUtitKSU48bue_0k',
    sheetName: 'Users',
    columns: [
      { columnIndex: 0, attributeName: 'id', type: 'string' },
      { columnIndex: 1, attributeName: 'name', type: 'string' },
      { columnIndex: 2, attributeName: 'email', type: 'string' },
      { columnIndex: 3, attributeName: 'numberOfChildren', type: 'number' },
      { columnIndex: 4, attributeName: 'createdAt', type: 'date' },
    ],
  };
  // Initialize repository and service
  const userRepository = await createSheetsRepository<User>(sheets, userTableConfig);

  // Create user
  const id = crypto.randomUUID();
  await userRepository.insert({
    id,
    name: 'John Doe',
    email: 'john@example.com',
    numberOfChildren: 2,
    createdAt: new Date(),
  });
  logger.info('New user created');

  // // Find all users
  // const users = await userRepository.findAll();
  // logger.info('All Users', { length: users });

  // Find user
  const user = await userRepository.findBy({ id: '333' });
  logger.info('User found', { user });

  // // Search users
  // const usersFoundBy = await userRepository.findBy({ name: 'John Doe' });
  // logger.info('Users found', usersFoundBy);

  // // Update user
  // const updatedUser = await userRepository.update('1', { name: 'Jane Doe' });
  // logger.info('User updated', updatedUser);

  // // Delete user
  // const deleted = await userRepository.delete('1');
  // logger.info('User deleted', deleted);
};

example();


// Filename: package.json
{
  "name": "googlesheet-litedb",
  "module": "src/index.ts",
  "type": "module",
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/bun": "latest",
    "eslint": "^9.17.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-security": "^3.0.1",
    "eslint-plugin-unicorn": "^56.0.1",
    "typescript-eslint": "^8.19.1"
  },
  "peerDependencies": {
    "typescript": "^5.0.0"
  },
  "dependencies": {
    "google-auth-library": "^9.15.0",
    "google-spreadsheet": "^4.1.4",
    "googleapis": "^144.0.0",
    "winston": "^3.17.0"
  },
  "scripts": {
    "lint": "eslint"
  }
}

// Filename: src/helpers/build-range/index.ts
const ASCII_A = 65;

const getColumnLetter = (index: number): string => {
  let result = '';
  index++;
  while (index > 0) {
    index--;
    result = String.fromCharCode(ASCII_A + (index % 26)) + result;
    index = Math.floor(index / 26);
  }
  return result;
};

export const buildRange = (sheetName: string, startColIndex: number, endColIndex: number, startRow?: number, endRow?: number): string => {
  const startColLetter = getColumnLetter(startColIndex);
  const endColLetter = getColumnLetter(endColIndex);
  const start = startRow ? `${startColLetter}${startRow}` : startColLetter;
  const end = endRow ? `${endColLetter}${endRow}` : endColLetter;
  return `${sheetName}!${start}:${end}`;
};


// Filename: src/helpers/create-google-auth-client/index.ts
import { AuthClient, GoogleAuth } from 'google-auth-library';



export const createGoogleAuthClient = async (): Promise<AuthClient> => {
  // This will use gcloud CLI credentials
  const auth = new GoogleAuth({ scopes: defaultScopes });

  const client = await auth.getClient();
  return client;
};


// Filename: src/helpers/error/index.ts
type ErrorWithMessage = {
  message: string;
};

const isErrorWithMessage = (error: unknown): error is ErrorWithMessage =>
  typeof error === 'object' && error !== null && 'message' in error && typeof (error as Record<string, unknown>).message === 'string';

const toErrorWithMessage = (maybeError: unknown): ErrorWithMessage => {
  if (isErrorWithMessage(maybeError)) {
    return maybeError;
  }

  try {
    return new Error(JSON.stringify(maybeError));
  } catch {
    // fallback in case there's an error stringifying the maybeError
    // like with circular references for example.
    return new Error(String(maybeError));
  }
};

export const getErrorMessage = (error: unknown): string => toErrorWithMessage(error).message;


// Filename: src/helpers/fetch-column-matches/index.ts
import type { sheets_v4 } from 'googleapis';
import type { TableConfig } from '../../types/config';
import { buildRange } from '../build-range';

export const fetchColumnMatches = async (
  searchColumns: TableConfig['columns'],
  stringifiedCriteria: Record<string, string | number>,
  sheets: sheets_v4.Sheets,
  spreadsheetId: string,
  sheetName: string
): Promise<number[][]> => {
  return Promise.all(
    searchColumns.map(async (column) => {
      const range = buildRange(sheetName, column.columnIndex, column.columnIndex);
      const rowsResponse = await sheets.spreadsheets.values.get({ spreadsheetId, range });
      const columnValues = rowsResponse.data.values?.map((row) => row[0] as string) || [];

      return columnValues.flatMap((value, index) => {
        const criteriaValue = stringifiedCriteria[column.attributeName];
        if (column.type === 'number') {
          return Number(value) === criteriaValue ? index : [];
        }
        return value === criteriaValue ? index : [];
      });
    })
  );
};


// Filename: src/helpers/fetch-rows-for-indexes/index.ts
import type { sheets_v4 } from 'googleapis';
import { buildRange } from '../build-range';

export const fetchRowsForIndexes = async (
  sheets: sheets_v4.Sheets,
  spreadsheetId: string,
  sheetName: string,
  firstColumnIndex: number,
  lastColumnIndex: number,
  separatedIndexes: number[][]
): Promise<string[][]> => {
  const rowFetchPromises = separatedIndexes.map(async (indexes) => {
    const start = indexes[0];
    const end = indexes[indexes.length - 1];
    const range = buildRange(sheetName, firstColumnIndex, lastColumnIndex, start + 1, end + 1);
    const rowsResponse = await sheets.spreadsheets.values.get({ spreadsheetId, range });
    return rowsResponse.data.values || [];
  });

  return (await Promise.all(rowFetchPromises)).flat();
};


// Filename: src/helpers/get-column-range/index.ts
import type { TableConfig } from '../../types/config';

export const getColumnRange = (columns: TableConfig['columns']): [number, number] => {
  const columnIndexes = columns.map((col) => col.columnIndex);
  return [Math.min(...columnIndexes), Math.max(...columnIndexes)];
};


// Filename: src/helpers/get-common-row-indexes/index.ts
export const getCommonRowIndexes = (columnMatches: number[][]): number[] => {
  return columnMatches.reduce((acc, indexes) => acc.filter((index) => indexes.includes(index)), columnMatches[0] || []);
};


// Filename: src/helpers/get-search-columns/index.ts
import type { TableConfig } from '../../types/config';

export const getSearchColumns = <T>(criteria: Partial<T>, columns: TableConfig['columns']): TableConfig['columns'] => {
  const searchFields = Object.keys(criteria);
  return columns.filter((column) => searchFields.includes(column.attributeName));
};


// Filename: src/helpers/manage-sheet-header/index.ts
import type { ColumnsConfig, SheetsConfig } from '../../types/config';
import type { SheetsInstance } from '../initialize-google-sheets';

export const manageSheetHeaders = async (sheetsInstance: SheetsInstance, config: SheetsConfig, columnsConfig: ColumnsConfig): Promise<string[]> => {
  const headerResponse = await sheetsInstance.sheets.spreadsheets.values.get({
    spreadsheetId: sheetsInstance.spreadsheetId,
    range: `${config.sheetName}!1:1`,
  });

  const existingHeaders = headerResponse.data.values?.at(0) ?? [];
  const configHeaders = columnsConfig.map((col) => col.name);

  // Find missing headers
  const missingHeaders = configHeaders.filter((header) => !existingHeaders.includes(header));

  if (missingHeaders.length > 0) {
    // Append missing headers
    await sheetsInstance.sheets.spreadsheets.values.update({
      spreadsheetId: sheetsInstance.spreadsheetId,
      range: `${config.sheetName}!1:1`,
      valueInputOption: 'RAW',
      requestBody: {
        values: [[...existingHeaders, ...missingHeaders]],
      },
    });
  }

  return [...existingHeaders, ...missingHeaders];
};


// Filename: src/helpers/map-rows-to-entities/index.ts
import type { TableConfig } from '../../types/config';
import { restoreObjectFromString } from '../object-to-string-converter';

export const mapRowsToEntities = <T>(rows: string[][], tableConfig: TableConfig): T[] => {
  const { columns } = tableConfig;

  return rows.map((row) => {
    const stringObject: Record<string, string> = {};

    columns.forEach((column) => {
      const { columnIndex, attributeName } = column;
      stringObject[String(attributeName)] = row.at(columnIndex) ?? '';
    });

    return restoreObjectFromString<T>(stringObject, tableConfig);
  });
};


// Filename: src/helpers/object-to-string-converter/index.ts
import type { TableConfig } from '../../types/config';

export const convertObjectValuesToString = <T>(object: T, tableConfig: TableConfig): Record<string, string | number> => {
  const result: Record<string, string | number> = {};

  tableConfig.columns.forEach(({ attributeName, type }) => {
    const value = object[attributeName as keyof T];

    if (value === undefined || value === null) {
      result[String(attributeName)] = '';
      return;
    }

    switch (type) {
      case 'array':
      case 'object':
        result[String(attributeName)] = JSON.stringify(value);
        break;
      case 'boolean':
        result[String(attributeName)] = value.toString();
        break;
      case 'number':
        result[String(attributeName)] = value as number;
        break;
      case 'date':
        result[String(attributeName)] = value instanceof Date ? value.toISOString() : value.toString();
        break;
      default:
        result[String(attributeName)] = value.toString();
    }
  });

  return result;
};

export const restoreObjectFromString = <T>(stringObject: Record<string, string>, tableConfig: TableConfig): T => {
  const result: Record<string, unknown> = {};

  Object.entries(stringObject).forEach(([key, value]) => {
    if (!value) {
      result[String(key)] = null;
      return;
    }

    const column = tableConfig.columns.find((c) => c.attributeName === key);
    const type = column?.type ?? 'string';

    switch (type) {
      case 'array':
      case 'object':
        try {
          result[String(key)] = JSON.parse(value);
        } catch {
          result[String(key)] = value;
        }
        break;
      case 'boolean':
        result[String(key)] = value.toLowerCase() === 'true';
        break;
      case 'date':
        result[String(key)] = new Date(value);
        break;
      case 'number':
        result[String(key)] = Number(value);
        break;
      default:
        result[String(key)] = value;
    }
  });

  return result as T;
};


// Filename: src/helpers/separate-consecutive-number/index.ts
export const separateConsecutiveNumbers = (arr: number[]): number[][] => {
  if (arr.length === 0) return [];

  const result: number[][] = [];
  let currentGroup: number[] = [arr[0]];
  for (let i = 1; i < arr.length; i++) {
    const current = arr.at(i);
    const previous = arr.at(i - 1);
    if (!current || !previous) continue;
    if (current === previous + 1) {
      currentGroup.push(current);
    } else {
      result.push(currentGroup);
      currentGroup = [current];
    }
  }

  result.push(currentGroup);
  return result;
};


// Filename: src/repository/find-all/index.ts
import type { sheets_v4 } from 'googleapis';
import { buildRange } from '../../helpers/build-range';
import { mapRowsToEntities } from '../../helpers/map-rows-to-entities';
import type { TableConfig } from '../../types/config';

export const findAll = async <T>(sheets: sheets_v4.Sheets, tableConfig: TableConfig): Promise<T[]> => {
  const { sheetName, spreadsheetId, columns } = tableConfig;

  const firstColumnIndex = Math.min(...columns.map((column) => column.columnIndex));
  const lastColumnIndex = Math.max(...columns.map((column) => column.columnIndex));
  const range = buildRange(sheetName, firstColumnIndex, lastColumnIndex, 2);

  const rowsResponse = await sheets.spreadsheets.values.get({ spreadsheetId, range });

  const rows = rowsResponse.data.values ?? [];
  return mapRowsToEntities<T>(rows, tableConfig);
};


// Filename: src/repository/find-by/index.ts
import type { sheets_v4 } from 'googleapis';
import { fetchColumnMatches } from '../../helpers/fetch-column-matches';
import { fetchRowsForIndexes } from '../../helpers/fetch-rows-for-indexes';
import { getColumnRange } from '../../helpers/get-column-range';
import { getCommonRowIndexes } from '../../helpers/get-common-row-indexes';
import { getSearchColumns } from '../../helpers/get-search-columns';
import { mapRowsToEntities } from '../../helpers/map-rows-to-entities';
import { convertObjectValuesToString } from '../../helpers/object-to-string-converter';
import { separateConsecutiveNumbers } from '../../helpers/separate-consecutive-number';
import type { TableConfig } from '../../types/config';

export const findBy = async <T>(criteria: Partial<T>, sheets: sheets_v4.Sheets, tableConfig: TableConfig): Promise<T[]> => {
  if (Object.keys(criteria).length === 0) return [];

  const { sheetName, spreadsheetId, columns } = tableConfig;
  const stringifiedCriteria = convertObjectValuesToString(criteria, tableConfig);

  const searchColumns = getSearchColumns(criteria, columns);

  const columnMatches = await fetchColumnMatches(searchColumns, stringifiedCriteria, sheets, spreadsheetId, sheetName);
  const commonRowIndexes = getCommonRowIndexes(columnMatches);
  if (commonRowIndexes.length === 0) return [];

  const separatedIndexes = separateConsecutiveNumbers(commonRowIndexes);
  const [firstColumnIndex, lastColumnIndex] = getColumnRange(columns);
  const rows = await fetchRowsForIndexes(sheets, spreadsheetId, sheetName, firstColumnIndex, lastColumnIndex, separatedIndexes);

  return mapRowsToEntities<T>(rows, tableConfig);
};


// Filename: src/repository/index.ts
import { sheets_v4 } from 'googleapis';
import type { TableConfig } from '../types/config';
import type { Repository } from '../types/repository';
import { findAll } from './find-all';
import { findBy } from './find-by';
import { insert } from './insert';

export type SheetConfig = {
  sheets: sheets_v4.Sheets;
  spreadsheetId: string;
  sheetName: string;
};
export const createSheetsRepository = async <T>(sheets: sheets_v4.Sheets, tableConfig: TableConfig): Promise<Repository<T>> => {
  return {
    insert: (entity: T) => insert<T>(entity, sheets, tableConfig),
    findAll: () => findAll<T>(sheets, tableConfig),
    findBy: (criteria: Partial<T>) => findBy<T>(criteria, sheets, tableConfig),

    //updateBy,
    // deleteBy,
  };
};


// Filename: src/repository/insert/index.ts
import type { sheets_v4 } from 'googleapis';
import { buildRange } from '../../helpers/build-range';
import { convertObjectValuesToString } from '../../helpers/object-to-string-converter';
import type { TableConfig } from '../../types/config';

export const insert = async <T>(entity: T, sheets: sheets_v4.Sheets, tableConfig: TableConfig): Promise<void> => {
  const { spreadsheetId, sheetName, columns } = tableConfig;
  const stringifiedEntity = convertObjectValuesToString(entity, tableConfig);

  const firstColumnIndex = Math.min(...columns.map((column) => column.columnIndex));
  const lastColumnIndex = Math.max(...columns.map((column) => column.columnIndex));

  const row = Array(lastColumnIndex - firstColumnIndex + 1)
    .fill('')
    .map((_, index) => {
      const column = columns.find((col) => col.columnIndex === index + firstColumnIndex);
      return column ? (stringifiedEntity[String(column.attributeName)] ?? '') : '';
    });

  const range = buildRange(sheetName, firstColumnIndex, lastColumnIndex);

  await sheets.spreadsheets.values.append({
    spreadsheetId,
    range,
    valueInputOption: 'RAW',
    requestBody: { values: [row] },
  });
};


// Filename: src/types/config/index.ts
export type ColumnConfig = {
  columnIndex: number;
  attributeName: string;
  type: 'string' | 'number' | 'date' | 'boolean' | 'array' | 'object';
};

export type TableConfig = {
  spreadsheetId: string;
  sheetName: string;
  columns: ColumnConfig[];
};


// Filename: src/types/logger/index.ts
export type Logger = {
  info(message: string, object?: object): void;
  error(message: string, object?: object): void;
};


// Filename: src/types/repository/index.ts
export type Repository<T> = {
  insert(entity: T): Promise<void>;
  findAll(): Promise<T[]>;
  findBy(criteria: Partial<T>): Promise<T[]>;
  // updateBy(idCriteria: Partial<T>, entity: Partial<T>): Promise<T>;
  // deleteBy(idCriteria: Partial<T>): Promise<boolean>;
};


// Filename: src/types/result/index.ts
type Fail<ERROR> = {
  data?: never;
  error: ERROR;
};

type Success<RESPONSE> = {
  error?: never;
  data: RESPONSE;
};

export type Result<RESPONSE, ERROR> = NonNullable<Success<RESPONSE> | Fail<ERROR>>;

export const createFail = <ERROR>(error: ERROR): Fail<ERROR> => ({ error });

export const createSuccess = <RESPONSE>(data: RESPONSE): Success<RESPONSE> => ({ data });

export const createSuccessVoid = (): Success<void> => ({ data: undefined });


// Filename: tsconfig.json
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}


